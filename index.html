<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>the-future.sh</title>
    
    <!-- Libraries and Fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Roboto+Mono:wght@400;700&display=swap" rel="stylesheet">
    <script src="https://unpkg.com/typed.js@2.1.0/dist/typed.umd.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js" xintegrity="sha512-BNaRQnYJYiPSqHHDb58B0yaPfCu+Wgds8Gp/gU33kqBtgNS4tSPHuGibyoVBL5gI9kLmbG4dGzcSTjpTJpe1pQ==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>

    <style>
        /* --- Global Styles --- */
        :root {
            --background-color: #0d1117;
            --text-color: #c9d1d9;
            --prompt-color: #58a6ff;
            --accent-color: #56d364;
            --error-color: #f85149;
            --font-family: 'Roboto Mono', 'SF Mono', 'Courier New', monospace;
        }

        html, body {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            background-color: var(--background-color);
            color: var(--text-color);
            font-family: var(--font-family);
            font-size: 16px;
            line-height: 1.6;
        }

        #header-container {
            padding: 20px 20px 0 20px;
            box-sizing: border-box;
        }

        #terminal {
            padding: 20px;
            box-sizing: border-box;
            height: calc(100% - 40px);
            overflow-y: auto;
            cursor: text;
        }

        .line {
            white-space: pre-wrap;
            word-break: break-all;
            min-height: 1.6em;
        }

        .prompt {
            color: var(--prompt-color);
            margin-right: 0.5em;
        }
        
        .command-input-container {
            display: flex;
            flex-grow: 1;
        }

        .terminal-input {
            background: transparent;
            border: none;
            outline: none;
            color: var(--text-color);
            font-family: inherit;
            font-size: inherit;
            caret-color: var(--accent-color);
            flex-grow: 1;
            padding: 0;
        }

        .log-fatal { color: var(--error-color); }
        .log-info { color: var(--prompt-color); }
        .log-ok { color: var(--accent-color); }
        .log-tip { color: #8b949e; }

        #share-container {
            display: none;
            padding: 15px;
            border: 1px solid #30363d;
            border-radius: 6px;
            background-color: #161b22;
            margin-bottom: 20px;
        }

        #share-container img {
            max-width: 100%;
            border-radius: 6px;
            border: 1px solid #30363d;
            margin-top: 10px;
        }

        .share-buttons {
            margin-top: 15px;
            display: flex;
            gap: 10px;
        }

        .share-button {
            background-color: var(--accent-color);
            color: var(--background-color);
            border: none;
            padding: 10px 15px;
            border-radius: 6px;
            font-family: inherit;
            font-weight: bold;
            cursor: pointer;
            text-decoration: none;
            text-align: center;
            transition: opacity 0.2s;
        }
        .share-button:hover {
            opacity: 0.8;
        }
        
        /* Intro animation styles */
        .typing-cursor {
            display: inline-block;
            width: 0.6em;
            height: 1.2em;
            background-color: var(--accent-color);
            animation: cursor-blink 1s infinite;
            vertical-align: text-bottom;
            margin-left: 2px;
        }
        
        @keyframes cursor-blink {
            0%, 49% { opacity: 1; }
            50%, 100% { opacity: 0; }
        }
        
        .intro-line {
            pointer-events: none;
        }
        
        .command-execute {
            animation: execute-flash 0.3s ease-out;
        }
        
        @keyframes execute-flash {
            0% { background-color: transparent; }
            50% { background-color: rgba(88, 166, 255, 0.1); }
            100% { background-color: transparent; }
        }
    </style>
</head>
<body>
    <div id="header-container"></div>
    
    <div id="terminal">
        <!-- JavaScript will populate content here -->
    </div>

    <script>
        // --- DOM Elements & Settings ---
        const headerContainer = document.getElementById('header-container');
        const terminal = document.getElementById('terminal');
        let currentInput = null;
        const commandHistory = [];
        let historyIndex = -1;
        let interactiveMode = false;
        let interactiveStep = null;
        let interactiveVision = '';
        let interactiveCommit = '';
        let currentLanguage = 'en'; // default to English
        
        // File system structure
        const fileSystem = {
            'README.md': {
                content: [
                    '# the-future.sh',
                    '',
                    'A tiny CLI simulator to boot your future.',
                    '',
                    'Run ./boot_future.sh --vision "your vision" --commit "your action"'
                ]
            },
            'vision.txt': {
                content: ['Your vision awaits. Use ./boot_future.sh to define it.']
            },
            'boot_future.sh': {
                content: null, // Special handling - cannot be displayed
                protected: true
            }
        };
        
        // Available files for ls and tab completion
        const availableFiles = Object.keys(fileSystem);
        
        // i18n translations
        const i18n = {
            en: {
                fatal: '[FATAL] Core components missing. Future cannot be initialized.',
                requiredFlags: '        Required flags: --vision, --commit',
                usage: 'USAGE:',
                usageExample: '  ./boot_future.sh --vision "a world where..." --commit "what you will do now"',
                tip: '# Tip: A vision without a commit is just a dream.',
                interactiveWelcome: '[INTERACTIVE MODE] Welcome to the guided future boot process!',
                interactiveIntro: 'This mode will help you craft your vision and commitment step by step.',
                interactiveVisionPrompt: 'What is your vision for the future? (Type your answer and press Enter)',
                interactiveVisionExample: '# Example: "a world where everyone has access to education"',
                visionRecorded: 'Vision recorded',
                interactiveCommitPrompt: 'Now, what is the first concrete action you will take to make this vision real?',
                interactiveCommitExample: '# Example: "sign up for an online course today"',
                commitRecorded: 'First commit recorded',
                interactiveConfirmPrompt: 'Here\'s the command that will boot your future:',
                interactiveConfirm: 'Ready to execute? Type "yes" to proceed or "no" to cancel.',
                interactiveCancelled: 'Interactive mode cancelled. You can try again anytime.',
                executing: 'Executing command...',
                initializing: 'Initializing future with new parameters...',
                visionLocked: 'Vision locked',
                commitRegistered: 'First commit registered',
                bootComplete: 'Boot sequence complete.',
                processStarted: 'Future process started successfully.',
                daemonizing: 'Daemonizing... Your future is now running in the background. Keep committing.',
                generating: 'Generating a shareable snapshot...',
                shareText: 'Your future has been initiated! Share this moment.',
                downloadButton: 'Download Image',
                shareButton: 'Share on X',
                commandNotFound: 'command not found',
                helpUsage: 'Usage: ./boot_future.sh --vision "<vision>" --commit "<action>"',
                helpDescription: 'Boot your future by declaring your vision and committing to action.',
                helpOptions: 'Options:',
                helpVision: '  --vision "<text>"     Your vision for the future (required)',
                helpCommit: '  --commit "<text>"     Your first concrete action (required)',
                helpInteractive: '  --interactive         Start guided mode for beginners',
                helpHelp: '  --help                Show this help message',
                helpWhen: '  --when "<date>"       Deadline for starting (optional)',
                helpFirstStep: '  --first-step "<text>" The very first micro-action (optional)',
                helpWhy: '  --why "<text>"        Personal motivation (optional)',
                helpMilestone: '  --milestone "<text>"  Intermediate goal (optional)',
                helpExamples: 'Examples:',
                helpExample1: '  ./boot_future.sh --vision "a world of clean energy" --commit "install solar panels"',
                helpExample2: '  ./boot_future.sh --interactive',
                helpExample3: '  ./boot_future.sh --vision "become a developer" --commit "write code daily" \\',
                helpExample4: '    --first-step "install VS Code" --milestone "build first app" \\',
                helpExample5: '    --why "create solutions" --when "2025-01-01"',
                availableCommands: 'Available commands:',
                cmdBootFuture: '  ./boot_future.sh --vision "<vision>" --commit "<action>"  - Boot your future',
                cmdInteractive: '  ./boot_future.sh --interactive                            - Guided mode',
                cmdHelp: '  ./boot_future.sh --help                                   - Show help',
                cmdLs: '  ls                                                        - List files',
                cmdCat: '  cat <file>                                                - Display file contents',
                cmdClear: '  clear                                                     - Clear terminal',
                cmdPwd: '  pwd                                                       - Print working directory',
                cmdWhoami: '  whoami                                                    - Display current user',
                cmdHelpCmd: '  help                                                      - Show this help message',
                firstCheckpoint: 'First checkpoint',
                milestone: 'Milestone',
                drivenBy: 'Driven by',
                deadline: 'Deadline'
            },
            ja: {
                fatal: '[致命的エラー] コアコンポーネントが不足しています。未来を初期化できません。',
                requiredFlags: '        必須フラグ: --vision, --commit',
                usage: '使用方法:',
                usageExample: '  ./boot_future.sh --vision "〜な世界" --commit "今すぐやること"',
                tip: '# ヒント: コミットなきビジョンは、ただの願望です。',
                interactiveWelcome: '[対話モード] 未来起動プロセスへようこそ！',
                interactiveIntro: 'このモードでは、ビジョンとコミットメントを段階的に作成できます。',
                interactiveVisionPrompt: 'あなたの未来のビジョンは何ですか？（入力してEnterを押してください）',
                interactiveVisionExample: '# 例: "誰もが教育を受けられる世界"',
                visionRecorded: 'ビジョンを記録しました',
                interactiveCommitPrompt: 'このビジョンを実現するために、今すぐ取る最初の具体的な行動は何ですか？',
                interactiveCommitExample: '# 例: "今日オンラインコースに登録する"',
                commitRecorded: '最初のコミットを記録しました',
                interactiveConfirmPrompt: 'あなたの未来を起動するコマンドは以下の通りです：',
                interactiveConfirm: '実行する準備はできましたか？「yes」で続行、「no」でキャンセルします。',
                interactiveCancelled: '対話モードをキャンセルしました。いつでも再試行できます。',
                executing: 'コマンドを実行中...',
                initializing: '新しいパラメータで未来を初期化中...',
                visionLocked: 'ビジョンをロックしました',
                commitRegistered: '最初のコミットを登録しました',
                bootComplete: 'ブートシーケンス完了。',
                processStarted: '未来プロセスが正常に開始されました。',
                daemonizing: 'デーモン化中... あなたの未来はバックグラウンドで実行されています。コミットし続けてください。',
                generating: '共有可能なスナップショットを生成中...',
                shareText: 'あなたの未来が始動しました！この瞬間を共有しましょう。',
                downloadButton: '画像をダウンロード',
                shareButton: 'Xで共有',
                commandNotFound: 'コマンドが見つかりません',
                helpUsage: '使用方法: ./boot_future.sh --vision "<ビジョン>" --commit "<アクション>"',
                helpDescription: 'ビジョンを宣言し、行動にコミットすることで未来を起動します。',
                helpOptions: 'オプション:',
                helpVision: '  --vision "<テキスト>"  あなたの未来のビジョン（必須）',
                helpCommit: '  --commit "<テキスト>"  最初の具体的な行動（必須）',
                helpInteractive: '  --interactive         初心者向けガイドモード',
                helpHelp: '  --help                このヘルプメッセージを表示',
                helpWhen: '  --when "<日付>"       開始期限（オプション）',
                helpFirstStep: '  --first-step "<テキスト>" 最初の小さな行動（オプション）',
                helpWhy: '  --why "<テキスト>"    個人的な動機（オプション）',
                helpMilestone: '  --milestone "<テキスト>" 中間目標（オプション）',
                helpExamples: '例:',
                helpExample1: '  ./boot_future.sh --vision "クリーンエネルギーの世界" --commit "ソーラーパネルを設置"',
                helpExample2: '  ./boot_future.sh --interactive',
                helpExample3: '  ./boot_future.sh --vision "エンジニアになる" --commit "毎日コードを書く" \\',
                helpExample4: '    --first-step "VS Codeをインストール" --milestone "最初のアプリを作る" \\',
                helpExample5: '    --why "ソリューションを作りたい" --when "2025-01-01"',
                availableCommands: '使用可能なコマンド:',
                cmdBootFuture: '  ./boot_future.sh --vision "<ビジョン>" --commit "<アクション>"  - 未来を起動',
                cmdInteractive: '  ./boot_future.sh --interactive                            - ガイドモード',
                cmdHelp: '  ./boot_future.sh --help                                   - ヘルプを表示',
                cmdLs: '  ls                                                        - ファイル一覧',
                cmdCat: '  cat <ファイル>                                              - ファイル内容表示',
                cmdClear: '  clear                                                     - 画面クリア',
                cmdPwd: '  pwd                                                       - 現在のディレクトリ',
                cmdWhoami: '  whoami                                                    - 現在のユーザー',
                cmdHelpCmd: '  help                                                      - このヘルプを表示',
                firstCheckpoint: '最初のチェックポイント',
                milestone: 'マイルストーン',
                drivenBy: '動機',
                deadline: '期限'
            }
        };
        
        // Detect if text contains Japanese characters
        function containsJapanese(text) {
            return /[\u3040-\u309F\u30A0-\u30FF\u4E00-\u9FAF]/.test(text);
        }
        
        // Get translation
        function t(key) {
            return i18n[currentLanguage][key] || i18n.en[key];
        }

        // [NEW] Define the error message lines as a constant for reuse
        function getErrorLines() {
            return [
                { text: `<span class="log-fatal">${t('fatal')}</span>`},
                { text: t('requiredFlags')},
                { text: '' },
                { text: t('usage')},
                { text: t('usageExample')},
                { text: '' },
                { text: `<span class="log-tip">${t('tip')}</span>`}
            ];
        }

        // --- Initialization ---
        document.addEventListener('DOMContentLoaded', () => {
            terminal.addEventListener('click', () => {
                if (currentInput) {
                    currentInput.focus();
                }
            });
            runIntroAnimation();
        });

        // --- Helper Functions ---
        function addLine(text) {
            const line = document.createElement('div');
            line.className = 'line';
            line.innerHTML = text;
            terminal.appendChild(line);
            scrollToBottom();
            return line;
        }
        
        // Tab completion logic
        function handleTabCompletion(currentValue) {
            const parts = currentValue.split(' ');
            
            // Handle tab completion for cat command with files
            if (parts[0] === 'cat' && parts.length <= 2) {
                // If there's a space after cat, show files
                if (currentValue.includes(' ')) {
                    const partial = parts[1] || '';
                    
                    // Find matching files
                    const matches = availableFiles.filter(file => 
                        file.toLowerCase().startsWith(partial.toLowerCase())
                    );
                    
                    if (matches.length === 0) {
                        // No matches - do nothing
                        return { action: 'none' };
                    } else if (matches.length === 1) {
                        // Single match - auto-complete
                        return { 
                            action: 'complete',
                            value: `cat ${matches[0]}`
                        };
                    } else {
                        // Multiple matches - show options
                        return {
                            action: 'show-options',
                            options: matches
                        };
                    }
                }
            }
            
            // Handle tab completion for commands
            if (parts.length === 1 && !currentValue.includes(' ')) {
                const commands = ['cat', 'ls', 'clear', 'pwd', 'whoami', 'help', './boot_future.sh', 'boot_future.sh'];
                const partial = parts[0];
                
                const matches = commands.filter(cmd => 
                    cmd.toLowerCase().startsWith(partial.toLowerCase())
                );
                
                if (matches.length === 1) {
                    return { 
                        action: 'complete',
                        value: matches[0]
                    };
                } else if (matches.length > 1) {
                    return {
                        action: 'show-options',
                        options: matches
                    };
                }
            }
            
            return { action: 'none' };
        }
        
        // Display tab completion options
        function displayTabOptions(options) {
            addLine(options.join('   '));
        }
        
        // Attach input event listeners
        function attachInputListeners(input) {
            input.addEventListener('keydown', handleInputKeydown);
        }
        
        // Handle keydown events for input
        function handleInputKeydown(e) {
            const input = e.target;
            
            if (e.key === 'Enter') {
                const command = input.value.trim();
                if (command) {
                    commandHistory.push(command);
                }
                const parent = input.parentElement;
                parent.innerHTML = `<span class="prompt">$</span><span>${escapeHtml(command)}</span>`;
                input.disabled = true;
                currentInput = null;
                processCommand(command, parent);
            } else if (e.key === 'Tab') {
                e.preventDefault();
                const result = handleTabCompletion(input.value);
                
                switch(result.action) {
                    case 'complete':
                        input.value = result.value;
                        input.setSelectionRange(input.value.length, input.value.length);
                        break;
                    case 'show-options':
                        // Save current line
                        const currentLine = input.parentElement;
                        currentLine.innerHTML = `<span class="prompt">$</span> ${escapeHtml(input.value)}`;
                        
                        // Show options
                        displayTabOptions(result.options);
                        
                        // Create new input line with preserved value
                        createInputLine();
                        currentInput.value = input.value;
                        currentInput.setSelectionRange(input.value.length, input.value.length);
                        break;
                }
            } else if (e.key === 'ArrowUp') {
                e.preventDefault();
                if (historyIndex > 0) {
                    historyIndex--;
                    input.value = commandHistory[historyIndex];
                    input.setSelectionRange(input.value.length, input.value.length);
                }
            } else if (e.key === 'ArrowDown') {
                e.preventDefault();
                if (historyIndex < commandHistory.length - 1) {
                    historyIndex++;
                    input.value = commandHistory[historyIndex];
                    input.setSelectionRange(input.value.length, input.value.length);
                } else {
                    historyIndex = commandHistory.length;
                    input.value = '';
                }
            }
        }

        function createInputLine() {
            const line = document.createElement('div');
            line.className = 'line command-input-container';
            line.innerHTML = `<span class="prompt">$</span><input type="text" class="terminal-input" autofocus>`;
            terminal.appendChild(line);
            
            currentInput = line.querySelector('.terminal-input');
            currentInput.focus();
            historyIndex = commandHistory.length;

            attachInputListeners(currentInput);
            scrollToBottom();
        }

        // --- Core Logic ---
        function processCommand(command, lineElement) {
            // Handle shell environment commands
            const parts = command.split(' ');
            const cmd = parts[0];
            
            // Handle shell commands
            if (cmd === 'ls') {
                addLine(availableFiles.join('   '));
                createInputLine();
                return;
            } else if (cmd === 'cat') {
                // Handle missing operand
                if (!parts[1]) {
                    addLine('cat: missing operand');
                    addLine('Try \'cat --help\' for more information.');
                    createInputLine();
                    return;
                }
                
                // Handle --help
                if (parts[1] === '--help') {
                    addLine('Usage: cat [FILE]...');
                    addLine('Concatenate FILE(s) to standard output.');
                    addLine('');
                    addLine('Examples:');
                    addLine('  cat README.md    Display contents of README.md');
                    addLine('  cat vision.txt   Display contents of vision.txt');
                    createInputLine();
                    return;
                }
                
                // Trim any extra spaces
                const filename = parts.slice(1).join(' ').trim();
                
                // Check if file exists
                if (fileSystem[filename]) {
                    const file = fileSystem[filename];
                    
                    // Handle protected files
                    if (file.protected) {
                        addLine(`<span class="log-fatal">cat: ${filename}: Permission denied (source is protected)</span>`);
                    } else if (file.content) {
                        // Display file content
                        file.content.forEach(line => addLine(line));
                    }
                } else {
                    addLine(`cat: ${filename}: No such file or directory`);
                }
                createInputLine();
                return;
            } else if (cmd === 'clear') {
                terminal.innerHTML = '';
                createInputLine();
                return;
            } else if (cmd === 'pwd') {
                addLine('/home/future/commits');
                createInputLine();
                return;
            } else if (cmd === 'whoami') {
                addLine('builder');
                createInputLine();
                return;
            } else if (cmd === 'help') {
                addLine(t('availableCommands'));
                addLine(t('cmdBootFuture'));
                addLine(t('cmdInteractive'));
                addLine(t('cmdHelp'));
                addLine(t('cmdLs'));
                addLine(t('cmdCat'));
                addLine(t('cmdClear'));
                addLine(t('cmdPwd'));
                addLine(t('cmdWhoami'));
                addLine(t('cmdHelpCmd'));
                createInputLine();
                return;
            }
            
            // Check for boot_future.sh commands
            const bootRegex = /^(?:\.\/)?(boot_future\.sh)(.*)$/;
            const bootMatch = command.match(bootRegex);
            
            if (bootMatch) {
                const args = bootMatch[2].trim();
                
                // Handle --interactive flag
                if (args === '--interactive') {
                    lineElement.classList.add('shareable-log');
                    startInteractiveMode();
                    return;
                }
                
                // Handle --help flag
                if (args === '--help') {
                    addLine(t('helpUsage'));
                    addLine('');
                    addLine(t('helpDescription'));
                    addLine('');
                    addLine(t('helpOptions'));
                    addLine(t('helpVision'));
                    addLine(t('helpCommit'));
                    addLine(t('helpWhen'));
                    addLine(t('helpFirstStep'));
                    addLine(t('helpWhy'));
                    addLine(t('helpMilestone'));
                    addLine(t('helpInteractive'));
                    addLine(t('helpHelp'));
                    addLine('');
                    addLine(t('helpExamples'));
                    addLine(t('helpExample1'));
                    addLine(t('helpExample2'));
                    addLine(t('helpExample3'));
                    addLine(t('helpExample4'));
                    addLine(t('helpExample5'));
                    createInputLine();
                    return;
                }
                
                // Check for vision and commit flags (required)
                const visionMatch = args.match(/--vision\s+["']([^"']+)["']/);
                const commitMatch = args.match(/--commit\s+["']([^"']+)["']/);
                
                if (visionMatch && commitMatch) {
                    lineElement.classList.add('shareable-log');
                    const vision = visionMatch[1];
                    const commit = commitMatch[1];
                    
                    // Check for optional extended flags
                    const whenMatch = args.match(/--when\s+["']([^"']+)["']/);
                    const firstStepMatch = args.match(/--first-step\s+["']([^"']+)["']/);
                    const whyMatch = args.match(/--why\s+["']([^"']+)["']/);
                    const milestoneMatch = args.match(/--milestone\s+["']([^"']+)["']/);
                    
                    const extendedOptions = {
                        when: whenMatch ? whenMatch[1] : null,
                        firstStep: firstStepMatch ? firstStepMatch[1] : null,
                        why: whyMatch ? whyMatch[1] : null,
                        milestone: milestoneMatch ? milestoneMatch[1] : null
                    };
                    
                    // Auto-detect language based on input
                    const allText = vision + commit + (extendedOptions.when || '') + 
                                   (extendedOptions.firstStep || '') + (extendedOptions.why || '') + 
                                   (extendedOptions.milestone || '');
                    if (containsJapanese(allText)) {
                        currentLanguage = 'ja';
                    } else {
                        currentLanguage = 'en';
                    }
                    
                    runSuccessSequence(vision, commit, false, extendedOptions);
                } else if (args === '') {
                    // Handle bare ./boot_future.sh
                    lineElement.classList.add('shareable-log');
                    runErrorSequence(() => {
                        setTimeout(createInputLine, 200);
                    });
                } else {
                    // Invalid arguments
                    lineElement.classList.add('shareable-log');
                    runErrorSequence(() => {
                        setTimeout(createInputLine, 200);
                    });
                }
            } else {
                // Command not found
                if (command) {
                    addLine(`zsh: ${t('commandNotFound')}: ${escapeHtml(command.split(' ')[0])}`);
                }
                createInputLine();
            }
        }

        // --- Animation Sequences ---
        // Interactive mode functions
        function startInteractiveMode() {
            interactiveMode = true;
            interactiveStep = 'intro';
            
            addLine('');
            addLine(`<span class="log-info">${t('interactiveWelcome')}</span>`);
            addLine('');
            addLine(t('interactiveIntro'));
            addLine('');
            addLine(t('interactiveVisionPrompt'));
            addLine(`<span class="log-tip">${t('interactiveVisionExample')}</span>`);
            addLine('');
            
            createInteractiveInput();
        }
        
        function createInteractiveInput() {
            const line = document.createElement('div');
            line.className = 'line command-input-container';
            line.innerHTML = `<span class="prompt">></span><input type="text" class="terminal-input" autofocus>`;
            terminal.appendChild(line);
            
            currentInput = line.querySelector('.terminal-input');
            currentInput.focus();
            
            currentInput.addEventListener('keydown', (e) => {
                if (e.key === 'Enter') {
                    const value = currentInput.value.trim();
                    if (!value) return;
                    
                    const parent = currentInput.parentElement;
                    parent.innerHTML = `<span class="prompt">></span><span>${escapeHtml(value)}</span>`;
                    currentInput.disabled = true;
                    currentInput = null;
                    
                    handleInteractiveInput(value);
                }
            });
            scrollToBottom();
        }
        
        function handleInteractiveInput(value) {
            if (interactiveStep === 'intro') {
                interactiveVision = value;
                interactiveStep = 'commit';
                
                addLine('');
                addLine(`<span class="log-ok">[ OK ]</span> ${t('visionRecorded')}: "${escapeHtml(value)}"`);
                addLine('');
                addLine(t('interactiveCommitPrompt'));
                addLine(`<span class="log-tip">${t('interactiveCommitExample')}</span>`);
                addLine('');
                
                createInteractiveInput();
            } else if (interactiveStep === 'commit') {
                interactiveCommit = value;
                interactiveStep = 'confirm';
                
                addLine('');
                addLine(`<span class="log-ok">[ OK ]</span> ${t('commitRecorded')}: "${escapeHtml(value)}"`);
                addLine('');
                addLine(t('interactiveConfirmPrompt'));
                addLine('');
                addLine(`<span class="log-info">$</span> ./boot_future.sh --vision "${escapeHtml(interactiveVision)}" --commit "${escapeHtml(interactiveCommit)}"`);
                addLine('');
                addLine(t('interactiveConfirm'));
                addLine('');
                
                createInteractiveInput();
            } else if (interactiveStep === 'confirm') {
                if (value.toLowerCase() === 'yes' || value.toLowerCase() === 'y' || value === 'はい' || value === 'はい、お願いします') {
                    interactiveMode = false;
                    
                    // Auto-detect language based on collected inputs
                    if (containsJapanese(interactiveVision) || containsJapanese(interactiveCommit)) {
                        currentLanguage = 'ja';
                    } else {
                        currentLanguage = 'en';
                    }
                    
                    addLine('');
                    addLine(t('executing'));
                    addLine('');
                    
                    // Mark the command line as shareable
                    const cmdLine = addLine(`$ ./boot_future.sh --vision "${escapeHtml(interactiveVision)}" --commit "${escapeHtml(interactiveCommit)}"`);
                    cmdLine.classList.add('shareable-log');
                    
                    runSuccessSequence(interactiveVision, interactiveCommit, true); // true indicates training mode
                } else {
                    interactiveMode = false;
                    addLine('');
                    addLine(t('interactiveCancelled'));
                    createInputLine();
                }
            }
        }
        
        // [NEW] A dedicated function to display the error message sequence
        function runErrorSequence(onComplete) {
            let delay = 0;
            const errorLines = getErrorLines();
            errorLines.forEach((line, index) => {
                setTimeout(() => {
                    const lineElement = addLine(line.text);
                    lineElement.classList.add('shareable-log');
                    if (index === errorLines.length - 1 && onComplete) {
                        onComplete();
                    }
                }, delay);
                delay += 100;
            });
        }

        function runIntroAnimation() {
            // Disable user interaction during animation
            terminal.style.pointerEvents = 'none';
            
            let animationActive = true;
            let timeouts = [];
            
            // Allow ESC key to skip animation
            function handleEscKey(e) {
                if (e.key === 'Escape' && animationActive) {
                    animationActive = false;
                    timeouts.forEach(timeout => clearTimeout(timeout));
                    document.removeEventListener('keydown', handleEscKey);
                    terminal.innerHTML = '';
                    terminal.style.pointerEvents = 'auto';
                    
                    // Show the final state immediately
                    const skipLine = addLine('$ ./boot_future.sh');
                    skipLine.classList.add('shareable-log');
                    commandHistory.push('./boot_future.sh');
                    runErrorSequence(() => {
                        createInputLine();
                    });
                }
            }
            document.addEventListener('keydown', handleEscKey);
            
            // Step 1: Show initial prompt with cursor (0ms)
            const introLine = document.createElement('div');
            introLine.className = 'line intro-line';
            introLine.innerHTML = '<span class="prompt">$</span> <span class="typing-text"></span><span class="typing-cursor"></span>';
            terminal.appendChild(introLine);
            
            const typingText = introLine.querySelector('.typing-text');
            const typingCursor = introLine.querySelector('.typing-cursor');
            
            // Step 2: Auto-typing phase (500ms - 1900ms)
            const command = './boot_future.sh';
            let charIndex = 0;
            
            function typeNextChar() {
                if (!animationActive) return;
                
                if (charIndex < command.length) {
                    typingText.textContent += command[charIndex];
                    charIndex++;
                    
                    // Vary typing speed: slower for "./boot_", faster for "future.sh"
                    const delay = charIndex <= 7 ? 50 : 30;
                    timeouts.push(setTimeout(typeNextChar, delay));
                } else {
                    // Step 2.5: Cursor blinks to show hesitation (1400ms - 1900ms)
                    timeouts.push(setTimeout(simulateEnterPress, 500));
                }
            }
            
            // Start typing after initial delay
            timeouts.push(setTimeout(typeNextChar, 500));
            
            function simulateEnterPress() {
                if (!animationActive) return;
                
                // Step 3: Enter key animation (1900ms - 2000ms)
                // Remove cursor and convert to executed command
                typingCursor.remove();
                introLine.innerHTML = `<span class="prompt">$</span> ${escapeHtml(command)}`;
                introLine.classList.remove('intro-line');
                introLine.classList.add('shareable-log');
                introLine.classList.add('command-execute');
                
                // Add to command history
                commandHistory.push(command);
                
                // Step 4: Error sequence display (2000ms - 3000ms)
                timeouts.push(setTimeout(() => {
                    if (!animationActive) return;
                    
                    runErrorSequence(() => {
                        // Step 5: Ready state (3000ms+)
                        animationActive = false;
                        document.removeEventListener('keydown', handleEscKey);
                        terminal.style.pointerEvents = 'auto';
                        createInputLine();
                    });
                }, 100));
            }
        }

        function runSuccessSequence(vision, commit, isTrainingMode = false, extendedOptions = {}) {
            const successLines = [
                { text: t('initializing') },
                { text: `<span class="log-info">[INFO]</span> ${t('visionLocked')}: "${escapeHtml(vision)}"` },
                { text: `<span class="log-info">[INFO]</span> ${t('commitRegistered')}: "${escapeHtml(commit)}"` },
                { text: `<span class="log-ok">[ OK ]</span> ${t('bootComplete')}` },
                { text: `` }
            ];
            
            // Generate PID and base message
            const pid = `${new Date().getFullYear()}${(new Date().getMonth() + 1).toString().padStart(2, '0')}${(new Date().getDate()).toString().padStart(2, '0')}`;
            
            // Check if we have extended options
            const hasExtendedOptions = extendedOptions.when || extendedOptions.firstStep || 
                                     extendedOptions.why || extendedOptions.milestone;
            
            if (hasExtendedOptions) {
                // Rich output format with tree structure
                successLines.push({ text: `${t('processStarted')} (PID: ${pid})` });
                
                if (extendedOptions.firstStep) {
                    successLines.push({ text: `├── ${t('firstCheckpoint')}: ${escapeHtml(extendedOptions.firstStep)}` });
                }
                if (extendedOptions.milestone) {
                    successLines.push({ text: `├── ${t('milestone')}: ${escapeHtml(extendedOptions.milestone)}` });
                }
                if (extendedOptions.why) {
                    successLines.push({ text: `├── ${t('drivenBy')}: ${escapeHtml(extendedOptions.why)}` });
                }
                if (extendedOptions.when) {
                    successLines.push({ text: `└── ${t('deadline')}: ${escapeHtml(extendedOptions.when)}` });
                }
            } else {
                // Simple output format
                successLines.push({ text: `${t('processStarted')} (PID: ${pid})` });
            }
            
            successLines.push({ text: t('daemonizing') });

            let delay = 0;
            successLines.forEach((line, index) => {
                setTimeout(() => {
                    const lineElement = addLine(line.text);
                    lineElement.classList.add('shareable-log');

                    if (index === successLines.length - 1) {
                        setTimeout(() => generateShareableImage(vision, commit, isTrainingMode, extendedOptions), 500);
                    }
                }, delay);
                delay += (line.text.length * 15) + 100;
            });
        }
        
        // --- Shareable Image Generation ---
        function generateShareableImage(vision, commit, isTrainingMode = false, extendedOptions = {}) {
            const generatingLine = addLine(t('generating'));
            generatingLine.classList.add('shareable-log');

            setTimeout(() => {
                const snapshotContainer = document.createElement('div');
                snapshotContainer.style.position = 'absolute';
                snapshotContainer.style.left = '-9999px';
                snapshotContainer.style.display = 'inline-block';
                snapshotContainer.style.padding = '20px';
                snapshotContainer.style.boxSizing = 'border-box';
                snapshotContainer.style.backgroundColor = getComputedStyle(document.documentElement).getPropertyValue('--background-color');
                snapshotContainer.style.fontFamily = getComputedStyle(document.documentElement).getPropertyValue('--font-family');
                snapshotContainer.style.fontSize = '16px';
                snapshotContainer.style.lineHeight = '1.6';
                snapshotContainer.style.color = getComputedStyle(document.documentElement).getPropertyValue('--text-color');

                const linesToShare = document.querySelectorAll('.shareable-log');
                linesToShare.forEach(line => {
                    snapshotContainer.appendChild(line.cloneNode(true));
                });

                document.body.appendChild(snapshotContainer);

                html2canvas(snapshotContainer, { logging: false, backgroundColor: null }).then(canvas => {
                    // Add training mode watermark if needed
                    if (isTrainingMode) {
                        const ctx = canvas.getContext('2d');
                        ctx.save();
                        ctx.font = 'bold 48px ' + getComputedStyle(document.documentElement).getPropertyValue('--font-family');
                        ctx.fillStyle = 'rgba(88, 166, 255, 0.3)';
                        ctx.textAlign = 'center';
                        ctx.translate(canvas.width / 2, canvas.height / 2);
                        ctx.rotate(-Math.PI / 6);
                        ctx.fillText('TRAINING MODE', 0, 0);
                        ctx.restore();
                    }
                    
                    const imageUrl = canvas.toDataURL('image/png');
                    document.body.removeChild(snapshotContainer);

                    headerContainer.innerHTML = '';

                    const shareContainer = document.createElement('div');
                    shareContainer.id = 'share-container';
                    
                    const shareText = currentLanguage === 'ja' 
                        ? `未来を起動しました！\n\nビジョン: ${vision}\nコミット: ${commit}\n\nあなたも未来を起動しよう: ${window.location.href}\n#BootYourFuture`
                        : `I've initiated my future!\n\nVision: ${vision}\nCommit: ${commit}\n\nBoot your own future at ${window.location.href}\n#BootYourFuture`;
                    const twitterUrl = `https://twitter.com/intent/tweet?text=${encodeURIComponent(shareText)}`;

                    shareContainer.innerHTML = `
                        <p>${t('shareText')}</p>
                        <div class="share-buttons">
                            <a href="${imageUrl}" download="the-future-sh.png" class="share-button">${t('downloadButton')}</a>
                            <a href="${twitterUrl}" target="_blank" class="share-button">${t('shareButton')}</a>
                        </div>
                        <img src="${imageUrl}" alt="A snapshot of the initiated future in the-future.sh">
                    `;
                    
                    headerContainer.appendChild(shareContainer);
                    shareContainer.style.display = 'block';
                    window.scrollTo(0, 0);
                });
            }, 100);
        }

        // --- Utility Functions ---
        function scrollToBottom() {
            terminal.scrollTop = terminal.scrollHeight;
        }

        function escapeHtml(unsafe) {
            return unsafe
                 .replace(/&/g, "&amp;")
                 .replace(/</g, "&lt;")
                 .replace(/>/g, "&gt;")
                 .replace(/"/g, "&quot;")
                 .replace(/'/g, "&#039;");
        }
    </script>
</body>
</html>
